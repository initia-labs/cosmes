// @generated by protoc-gen-es v1.7.0 with parameter "target=ts"
// @generated from file injective/ocr/v1beta1/ocr.proto (package injective.ocr.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from message injective.ocr.v1beta1.Params
 */
export class Params extends Message<Params> {
  /**
   * Native denom for LINK coin in the bank keeper
   *
   * @generated from field: string link_denom = 1;
   */
  linkDenom = "";

  /**
   * The block number interval at which payouts are made
   *
   * @generated from field: uint64 payout_block_interval = 2;
   */
  payoutBlockInterval = protoInt64.zero;

  /**
   * The admin for the OCR module
   *
   * @generated from field: string module_admin = 3;
   */
  moduleAdmin = "";

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "link_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payout_block_interval", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "module_admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedConfig
 */
export class FeedConfig extends Message<FeedConfig> {
  /**
   * signers ith element is address ith oracle uses to sign a report
   *
   * @generated from field: repeated string signers = 1;
   */
  signers: string[] = [];

  /**
   * transmitters ith element is address ith oracle uses to transmit a report
   * via the transmit method
   *
   * @generated from field: repeated string transmitters = 2;
   */
  transmitters: string[] = [];

  /**
   * f maximum number of faulty/dishonest oracles the protocol can tolerate
   * while still working correctly
   *
   * @generated from field: uint32 f = 3;
   */
  f = 0;

  /**
   * onchain_config serialized data with reporting plugin params on chain.
   *
   * @generated from field: bytes onchain_config = 4;
   */
  onchainConfig = new Uint8Array(0);

  /**
   * offchain_config_version version of the serialization format used for
   * "offchain_config" parameter
   *
   * @generated from field: uint64 offchain_config_version = 5;
   */
  offchainConfigVersion = protoInt64.zero;

  /**
   * offchain_config serialized data used by oracles to configure their offchain
   * operation
   *
   * @generated from field: bytes offchain_config = 6;
   */
  offchainConfig = new Uint8Array(0);

  /**
   * feed-specific params for the Cosmos module.
   *
   * @generated from field: injective.ocr.v1beta1.ModuleParams module_params = 7;
   */
  moduleParams?: ModuleParams;

  constructor(data?: PartialMessage<FeedConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "transmitters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "f", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "onchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "offchain_config_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "offchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "module_params", kind: "message", T: ModuleParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedConfig {
    return new FeedConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedConfig {
    return new FeedConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedConfig {
    return new FeedConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FeedConfig | PlainMessage<FeedConfig> | undefined, b: FeedConfig | PlainMessage<FeedConfig> | undefined): boolean {
    return proto3.util.equals(FeedConfig, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedConfigInfo
 */
export class FeedConfigInfo extends Message<FeedConfigInfo> {
  /**
   * @generated from field: bytes latest_config_digest = 1;
   */
  latestConfigDigest = new Uint8Array(0);

  /**
   * @generated from field: uint32 f = 2;
   */
  f = 0;

  /**
   * @generated from field: uint32 n = 3;
   */
  n = 0;

  /**
   * config_count ordinal number of this config setting among all config
   * settings
   *
   * @generated from field: uint64 config_count = 4;
   */
  configCount = protoInt64.zero;

  /**
   * @generated from field: int64 latest_config_block_number = 5;
   */
  latestConfigBlockNumber = protoInt64.zero;

  constructor(data?: PartialMessage<FeedConfigInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedConfigInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latest_config_digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "f", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "n", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "config_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "latest_config_block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedConfigInfo {
    return new FeedConfigInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedConfigInfo {
    return new FeedConfigInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedConfigInfo {
    return new FeedConfigInfo().fromJsonString(jsonString, options);
  }

  static equals(a: FeedConfigInfo | PlainMessage<FeedConfigInfo> | undefined, b: FeedConfigInfo | PlainMessage<FeedConfigInfo> | undefined): boolean {
    return proto3.util.equals(FeedConfigInfo, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.ModuleParams
 */
export class ModuleParams extends Message<ModuleParams> {
  /**
   * feed_id is an unique ID for the target of this config
   *
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * lowest answer the median of a report is allowed to be
   *
   * @generated from field: string min_answer = 2;
   */
  minAnswer = "";

  /**
   * highest answer the median of a report is allowed to be
   *
   * @generated from field: string max_answer = 3;
   */
  maxAnswer = "";

  /**
   * Fixed LINK reward for each observer
   *
   * @generated from field: string link_per_observation = 4;
   */
  linkPerObservation = "";

  /**
   * Fixed LINK reward for transmitter
   *
   * @generated from field: string link_per_transmission = 5;
   */
  linkPerTransmission = "";

  /**
   * Native denom for LINK coin in the bank keeper
   *
   * @generated from field: string link_denom = 6;
   */
  linkDenom = "";

  /**
   * Enables unique reports
   *
   * @generated from field: bool unique_reports = 7;
   */
  uniqueReports = false;

  /**
   * short human-readable description of observable this feed's answers pertain
   * to
   *
   * @generated from field: string description = 8;
   */
  description = "";

  /**
   * feed administrator
   *
   * @generated from field: string feed_admin = 9;
   */
  feedAdmin = "";

  /**
   * feed billing administrator
   *
   * @generated from field: string billing_admin = 10;
   */
  billingAdmin = "";

  constructor(data?: PartialMessage<ModuleParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.ModuleParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "min_answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "max_answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "link_per_observation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "link_per_transmission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "link_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "unique_reports", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "feed_admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "billing_admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleParams {
    return new ModuleParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleParams {
    return new ModuleParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleParams {
    return new ModuleParams().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleParams | PlainMessage<ModuleParams> | undefined, b: ModuleParams | PlainMessage<ModuleParams> | undefined): boolean {
    return proto3.util.equals(ModuleParams, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.ContractConfig
 */
export class ContractConfig extends Message<ContractConfig> {
  /**
   * config_count ordinal number of this config setting among all config
   * settings
   *
   * @generated from field: uint64 config_count = 1;
   */
  configCount = protoInt64.zero;

  /**
   * signers ith element is address ith oracle uses to sign a report
   *
   * @generated from field: repeated string signers = 2;
   */
  signers: string[] = [];

  /**
   * transmitters ith element is address ith oracle uses to transmit a report
   * via the transmit method
   *
   * @generated from field: repeated string transmitters = 3;
   */
  transmitters: string[] = [];

  /**
   * f maximum number of faulty/dishonest oracles the protocol can tolerate
   * while still working correctly
   *
   * @generated from field: uint32 f = 4;
   */
  f = 0;

  /**
   * onchain_config serialized data with reporting plugin params on chain.
   *
   * @generated from field: bytes onchain_config = 5;
   */
  onchainConfig = new Uint8Array(0);

  /**
   * offchain_config_version version of the serialization format used for
   * "offchain_config" parameter
   *
   * @generated from field: uint64 offchain_config_version = 6;
   */
  offchainConfigVersion = protoInt64.zero;

  /**
   * offchain_config serialized data used by oracles to configure their offchain
   * operation
   *
   * @generated from field: bytes offchain_config = 7;
   */
  offchainConfig = new Uint8Array(0);

  constructor(data?: PartialMessage<ContractConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.ContractConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "signers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "transmitters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "f", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "onchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "offchain_config_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "offchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContractConfig {
    return new ContractConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContractConfig {
    return new ContractConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContractConfig {
    return new ContractConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ContractConfig | PlainMessage<ContractConfig> | undefined, b: ContractConfig | PlainMessage<ContractConfig> | undefined): boolean {
    return proto3.util.equals(ContractConfig, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.SetConfigProposal
 */
export class SetConfigProposal extends Message<SetConfigProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: injective.ocr.v1beta1.FeedConfig config = 3;
   */
  config?: FeedConfig;

  constructor(data?: PartialMessage<SetConfigProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.SetConfigProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "config", kind: "message", T: FeedConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetConfigProposal {
    return new SetConfigProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetConfigProposal {
    return new SetConfigProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetConfigProposal {
    return new SetConfigProposal().fromJsonString(jsonString, options);
  }

  static equals(a: SetConfigProposal | PlainMessage<SetConfigProposal> | undefined, b: SetConfigProposal | PlainMessage<SetConfigProposal> | undefined): boolean {
    return proto3.util.equals(SetConfigProposal, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.FeedProperties
 */
export class FeedProperties extends Message<FeedProperties> {
  /**
   * feed_id is an unique ID for the target of this config
   *
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * f maximum number of faulty/dishonest oracles the protocol can tolerate
   * while still working correctly
   *
   * @generated from field: uint32 f = 2;
   */
  f = 0;

  /**
   * onchain_config serialized data with reporting plugin params on chain.
   *
   * @generated from field: bytes onchain_config = 3;
   */
  onchainConfig = new Uint8Array(0);

  /**
   * offchain_config_version version of the serialization format used for
   * "offchain_config" parameter
   *
   * @generated from field: uint64 offchain_config_version = 4;
   */
  offchainConfigVersion = protoInt64.zero;

  /**
   * offchain_config serialized data used by oracles to configure their offchain
   * operation
   *
   * @generated from field: bytes offchain_config = 5;
   */
  offchainConfig = new Uint8Array(0);

  /**
   * lowest answer the median of a report is allowed to be
   *
   * @generated from field: string min_answer = 6;
   */
  minAnswer = "";

  /**
   * highest answer the median of a report is allowed to be
   *
   * @generated from field: string max_answer = 7;
   */
  maxAnswer = "";

  /**
   * Fixed LINK reward for each observer
   *
   * @generated from field: string link_per_observation = 8;
   */
  linkPerObservation = "";

  /**
   * Fixed LINK reward for transmitter
   *
   * @generated from field: string link_per_transmission = 9;
   */
  linkPerTransmission = "";

  /**
   * Enables unique reports
   *
   * @generated from field: bool unique_reports = 10;
   */
  uniqueReports = false;

  /**
   * short human-readable description of observable this feed's answers pertain
   * to
   *
   * @generated from field: string description = 11;
   */
  description = "";

  constructor(data?: PartialMessage<FeedProperties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.FeedProperties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "f", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "onchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "offchain_config_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "offchain_config", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "min_answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "max_answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "link_per_observation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "link_per_transmission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "unique_reports", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedProperties {
    return new FeedProperties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedProperties {
    return new FeedProperties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedProperties {
    return new FeedProperties().fromJsonString(jsonString, options);
  }

  static equals(a: FeedProperties | PlainMessage<FeedProperties> | undefined, b: FeedProperties | PlainMessage<FeedProperties> | undefined): boolean {
    return proto3.util.equals(FeedProperties, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.SetBatchConfigProposal
 */
export class SetBatchConfigProposal extends Message<SetBatchConfigProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * signers ith element is address ith oracle uses to sign a report
   *
   * @generated from field: repeated string signers = 3;
   */
  signers: string[] = [];

  /**
   * transmitters ith element is address ith oracle uses to transmit a report
   * via the transmit method
   *
   * @generated from field: repeated string transmitters = 4;
   */
  transmitters: string[] = [];

  /**
   * Native denom for LINK coin in the bank keeper
   *
   * @generated from field: string link_denom = 5;
   */
  linkDenom = "";

  /**
   * feed properties
   *
   * @generated from field: repeated injective.ocr.v1beta1.FeedProperties feed_properties = 6;
   */
  feedProperties: FeedProperties[] = [];

  constructor(data?: PartialMessage<SetBatchConfigProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.SetBatchConfigProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "signers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "transmitters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "link_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "feed_properties", kind: "message", T: FeedProperties, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBatchConfigProposal {
    return new SetBatchConfigProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBatchConfigProposal {
    return new SetBatchConfigProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBatchConfigProposal {
    return new SetBatchConfigProposal().fromJsonString(jsonString, options);
  }

  static equals(a: SetBatchConfigProposal | PlainMessage<SetBatchConfigProposal> | undefined, b: SetBatchConfigProposal | PlainMessage<SetBatchConfigProposal> | undefined): boolean {
    return proto3.util.equals(SetBatchConfigProposal, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.OracleObservationsCounts
 */
export class OracleObservationsCounts extends Message<OracleObservationsCounts> {
  /**
   * @generated from field: repeated uint32 counts = 1;
   */
  counts: number[] = [];

  constructor(data?: PartialMessage<OracleObservationsCounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.OracleObservationsCounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "counts", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OracleObservationsCounts {
    return new OracleObservationsCounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OracleObservationsCounts {
    return new OracleObservationsCounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OracleObservationsCounts {
    return new OracleObservationsCounts().fromJsonString(jsonString, options);
  }

  static equals(a: OracleObservationsCounts | PlainMessage<OracleObservationsCounts> | undefined, b: OracleObservationsCounts | PlainMessage<OracleObservationsCounts> | undefined): boolean {
    return proto3.util.equals(OracleObservationsCounts, a, b);
  }
}

/**
 * LINK-INJ-denominated reimbursements for gas used by transmitters.
 *
 * @generated from message injective.ocr.v1beta1.GasReimbursements
 */
export class GasReimbursements extends Message<GasReimbursements> {
  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin reimbursements = 1;
   */
  reimbursements: Coin[] = [];

  constructor(data?: PartialMessage<GasReimbursements>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.GasReimbursements";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reimbursements", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GasReimbursements {
    return new GasReimbursements().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GasReimbursements {
    return new GasReimbursements().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GasReimbursements {
    return new GasReimbursements().fromJsonString(jsonString, options);
  }

  static equals(a: GasReimbursements | PlainMessage<GasReimbursements> | undefined, b: GasReimbursements | PlainMessage<GasReimbursements> | undefined): boolean {
    return proto3.util.equals(GasReimbursements, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.Payee
 */
export class Payee extends Message<Payee> {
  /**
   * @generated from field: string transmitter_addr = 1;
   */
  transmitterAddr = "";

  /**
   * @generated from field: string payment_addr = 2;
   */
  paymentAddr = "";

  constructor(data?: PartialMessage<Payee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.Payee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transmitter_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payment_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payee {
    return new Payee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payee {
    return new Payee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payee {
    return new Payee().fromJsonString(jsonString, options);
  }

  static equals(a: Payee | PlainMessage<Payee> | undefined, b: Payee | PlainMessage<Payee> | undefined): boolean {
    return proto3.util.equals(Payee, a, b);
  }
}

/**
 * Transmission records the median answer from the transmit transaction at
 * time timestamp
 *
 * @generated from message injective.ocr.v1beta1.Transmission
 */
export class Transmission extends Message<Transmission> {
  /**
   * @generated from field: string answer = 1;
   */
  answer = "";

  /**
   * when were observations made offchain
   *
   * @generated from field: int64 observations_timestamp = 2;
   */
  observationsTimestamp = protoInt64.zero;

  /**
   * when was report received onchain
   *
   * @generated from field: int64 transmission_timestamp = 3;
   */
  transmissionTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Transmission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.Transmission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "observations_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "transmission_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transmission {
    return new Transmission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transmission {
    return new Transmission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transmission {
    return new Transmission().fromJsonString(jsonString, options);
  }

  static equals(a: Transmission | PlainMessage<Transmission> | undefined, b: Transmission | PlainMessage<Transmission> | undefined): boolean {
    return proto3.util.equals(Transmission, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EpochAndRound
 */
export class EpochAndRound extends Message<EpochAndRound> {
  /**
   * @generated from field: uint64 epoch = 1;
   */
  epoch = protoInt64.zero;

  /**
   * @generated from field: uint64 round = 2;
   */
  round = protoInt64.zero;

  constructor(data?: PartialMessage<EpochAndRound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EpochAndRound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "round", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EpochAndRound {
    return new EpochAndRound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EpochAndRound {
    return new EpochAndRound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EpochAndRound {
    return new EpochAndRound().fromJsonString(jsonString, options);
  }

  static equals(a: EpochAndRound | PlainMessage<EpochAndRound> | undefined, b: EpochAndRound | PlainMessage<EpochAndRound> | undefined): boolean {
    return proto3.util.equals(EpochAndRound, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.Report
 */
export class Report extends Message<Report> {
  /**
   * @generated from field: int64 observations_timestamp = 1;
   */
  observationsTimestamp = protoInt64.zero;

  /**
   * ith element is the index of the ith observer
   *
   * @generated from field: bytes observers = 2;
   */
  observers = new Uint8Array(0);

  /**
   * ith element is the ith observation
   *
   * @generated from field: repeated string observations = 3;
   */
  observations: string[] = [];

  constructor(data?: PartialMessage<Report>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.Report";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "observations_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "observers", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "observations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Report {
    return new Report().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Report {
    return new Report().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Report {
    return new Report().fromJsonString(jsonString, options);
  }

  static equals(a: Report | PlainMessage<Report> | undefined, b: Report | PlainMessage<Report> | undefined): boolean {
    return proto3.util.equals(Report, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.ReportToSign
 */
export class ReportToSign extends Message<ReportToSign> {
  /**
   * @generated from field: bytes config_digest = 1;
   */
  configDigest = new Uint8Array(0);

  /**
   * @generated from field: uint64 epoch = 2;
   */
  epoch = protoInt64.zero;

  /**
   * @generated from field: uint64 round = 3;
   */
  round = protoInt64.zero;

  /**
   * @generated from field: bytes extra_hash = 4;
   */
  extraHash = new Uint8Array(0);

  /**
   * Opaque report
   *
   * @generated from field: bytes report = 5;
   */
  report = new Uint8Array(0);

  constructor(data?: PartialMessage<ReportToSign>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.ReportToSign";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "round", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "extra_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "report", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportToSign {
    return new ReportToSign().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportToSign {
    return new ReportToSign().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportToSign {
    return new ReportToSign().fromJsonString(jsonString, options);
  }

  static equals(a: ReportToSign | PlainMessage<ReportToSign> | undefined, b: ReportToSign | PlainMessage<ReportToSign> | undefined): boolean {
    return proto3.util.equals(ReportToSign, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventOraclePaid
 */
export class EventOraclePaid extends Message<EventOraclePaid> {
  /**
   * @generated from field: string transmitter_addr = 1;
   */
  transmitterAddr = "";

  /**
   * @generated from field: string payee_addr = 2;
   */
  payeeAddr = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventOraclePaid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventOraclePaid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transmitter_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payee_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOraclePaid {
    return new EventOraclePaid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOraclePaid {
    return new EventOraclePaid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOraclePaid {
    return new EventOraclePaid().fromJsonString(jsonString, options);
  }

  static equals(a: EventOraclePaid | PlainMessage<EventOraclePaid> | undefined, b: EventOraclePaid | PlainMessage<EventOraclePaid> | undefined): boolean {
    return proto3.util.equals(EventOraclePaid, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventAnswerUpdated
 */
export class EventAnswerUpdated extends Message<EventAnswerUpdated> {
  /**
   * @generated from field: string current = 1;
   */
  current = "";

  /**
   * @generated from field: string round_id = 2;
   */
  roundId = "";

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 3;
   */
  updatedAt?: Timestamp;

  constructor(data?: PartialMessage<EventAnswerUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventAnswerUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "round_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "updated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAnswerUpdated {
    return new EventAnswerUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAnswerUpdated {
    return new EventAnswerUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAnswerUpdated {
    return new EventAnswerUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: EventAnswerUpdated | PlainMessage<EventAnswerUpdated> | undefined, b: EventAnswerUpdated | PlainMessage<EventAnswerUpdated> | undefined): boolean {
    return proto3.util.equals(EventAnswerUpdated, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventNewRound
 */
export class EventNewRound extends Message<EventNewRound> {
  /**
   * @generated from field: string round_id = 1;
   */
  roundId = "";

  /**
   * address of starter
   *
   * @generated from field: string started_by = 2;
   */
  startedBy = "";

  /**
   * @generated from field: google.protobuf.Timestamp started_at = 3;
   */
  startedAt?: Timestamp;

  constructor(data?: PartialMessage<EventNewRound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventNewRound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "round_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "started_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "started_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewRound {
    return new EventNewRound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewRound {
    return new EventNewRound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewRound {
    return new EventNewRound().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewRound | PlainMessage<EventNewRound> | undefined, b: EventNewRound | PlainMessage<EventNewRound> | undefined): boolean {
    return proto3.util.equals(EventNewRound, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventTransmitted
 */
export class EventTransmitted extends Message<EventTransmitted> {
  /**
   * @generated from field: bytes config_digest = 1;
   */
  configDigest = new Uint8Array(0);

  /**
   * @generated from field: uint64 epoch = 2;
   */
  epoch = protoInt64.zero;

  constructor(data?: PartialMessage<EventTransmitted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventTransmitted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTransmitted {
    return new EventTransmitted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTransmitted {
    return new EventTransmitted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTransmitted {
    return new EventTransmitted().fromJsonString(jsonString, options);
  }

  static equals(a: EventTransmitted | PlainMessage<EventTransmitted> | undefined, b: EventTransmitted | PlainMessage<EventTransmitted> | undefined): boolean {
    return proto3.util.equals(EventTransmitted, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventNewTransmission
 */
export class EventNewTransmission extends Message<EventNewTransmission> {
  /**
   * @generated from field: string feed_id = 1;
   */
  feedId = "";

  /**
   * @generated from field: uint32 aggregator_round_id = 2;
   */
  aggregatorRoundId = 0;

  /**
   * @generated from field: string answer = 3;
   */
  answer = "";

  /**
   * @generated from field: string transmitter = 4;
   */
  transmitter = "";

  /**
   * @generated from field: int64 observations_timestamp = 5;
   */
  observationsTimestamp = protoInt64.zero;

  /**
   * @generated from field: repeated string observations = 6;
   */
  observations: string[] = [];

  /**
   * @generated from field: bytes observers = 7;
   */
  observers = new Uint8Array(0);

  /**
   * @generated from field: bytes config_digest = 8;
   */
  configDigest = new Uint8Array(0);

  /**
   * @generated from field: injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9;
   */
  epochAndRound?: EpochAndRound;

  constructor(data?: PartialMessage<EventNewTransmission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventNewTransmission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aggregator_round_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "answer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transmitter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "observations_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "observations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "observers", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "config_digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "epoch_and_round", kind: "message", T: EpochAndRound },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewTransmission {
    return new EventNewTransmission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewTransmission {
    return new EventNewTransmission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewTransmission {
    return new EventNewTransmission().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewTransmission | PlainMessage<EventNewTransmission> | undefined, b: EventNewTransmission | PlainMessage<EventNewTransmission> | undefined): boolean {
    return proto3.util.equals(EventNewTransmission, a, b);
  }
}

/**
 * @generated from message injective.ocr.v1beta1.EventConfigSet
 */
export class EventConfigSet extends Message<EventConfigSet> {
  /**
   * hash of the config
   *
   * @generated from field: bytes config_digest = 1;
   */
  configDigest = new Uint8Array(0);

  /**
   * previous_config_block_number block in which the previous config was set, to
   * simplify historic analysis
   *
   * @generated from field: int64 previous_config_block_number = 2;
   */
  previousConfigBlockNumber = protoInt64.zero;

  /**
   * @generated from field: injective.ocr.v1beta1.FeedConfig config = 3;
   */
  config?: FeedConfig;

  /**
   * @generated from field: injective.ocr.v1beta1.FeedConfigInfo config_info = 4;
   */
  configInfo?: FeedConfigInfo;

  constructor(data?: PartialMessage<EventConfigSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.ocr.v1beta1.EventConfigSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_digest", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "previous_config_block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "config", kind: "message", T: FeedConfig },
    { no: 4, name: "config_info", kind: "message", T: FeedConfigInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConfigSet {
    return new EventConfigSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConfigSet {
    return new EventConfigSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConfigSet {
    return new EventConfigSet().fromJsonString(jsonString, options);
  }

  static equals(a: EventConfigSet | PlainMessage<EventConfigSet> | undefined, b: EventConfigSet | PlainMessage<EventConfigSet> | undefined): boolean {
    return proto3.util.equals(EventConfigSet, a, b);
  }
}

