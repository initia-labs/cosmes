// @generated by protoc-gen-es v1.7.0 with parameter "target=ts"
// @generated from file injective/peggy/v1/query.proto (package injective.peggy.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { LastClaimEvent, Valset } from "./types_pb.js";
import { MsgConfirmBatch, MsgValsetConfirm } from "./msgs_pb.js";
import { BatchFees } from "./pool_pb.js";
import { OutgoingTransferTx, OutgoingTxBatch } from "./batch_pb.js";
import { GenesisState } from "./genesis_pb.js";

/**
 * @generated from message injective.peggy.v1.QueryParamsRequest
 */
export class QueryParamsRequest extends Message<QueryParamsRequest> {
  constructor(data?: PartialMessage<QueryParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined, b: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined): boolean {
    return proto3.util.equals(QueryParamsRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryParamsResponse
 */
export class QueryParamsResponse extends Message<QueryParamsResponse> {
  /**
   * @generated from field: injective.peggy.v1.Params params = 1;
   */
  params?: Params;

  constructor(data?: PartialMessage<QueryParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined, b: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined): boolean {
    return proto3.util.equals(QueryParamsResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryCurrentValsetRequest
 */
export class QueryCurrentValsetRequest extends Message<QueryCurrentValsetRequest> {
  constructor(data?: PartialMessage<QueryCurrentValsetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryCurrentValsetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCurrentValsetRequest {
    return new QueryCurrentValsetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCurrentValsetRequest {
    return new QueryCurrentValsetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCurrentValsetRequest {
    return new QueryCurrentValsetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCurrentValsetRequest | PlainMessage<QueryCurrentValsetRequest> | undefined, b: QueryCurrentValsetRequest | PlainMessage<QueryCurrentValsetRequest> | undefined): boolean {
    return proto3.util.equals(QueryCurrentValsetRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryCurrentValsetResponse
 */
export class QueryCurrentValsetResponse extends Message<QueryCurrentValsetResponse> {
  /**
   * @generated from field: injective.peggy.v1.Valset valset = 1;
   */
  valset?: Valset;

  constructor(data?: PartialMessage<QueryCurrentValsetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryCurrentValsetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valset", kind: "message", T: Valset },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCurrentValsetResponse {
    return new QueryCurrentValsetResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCurrentValsetResponse {
    return new QueryCurrentValsetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCurrentValsetResponse {
    return new QueryCurrentValsetResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCurrentValsetResponse | PlainMessage<QueryCurrentValsetResponse> | undefined, b: QueryCurrentValsetResponse | PlainMessage<QueryCurrentValsetResponse> | undefined): boolean {
    return proto3.util.equals(QueryCurrentValsetResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetRequestRequest
 */
export class QueryValsetRequestRequest extends Message<QueryValsetRequestRequest> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  constructor(data?: PartialMessage<QueryValsetRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetRequestRequest {
    return new QueryValsetRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetRequestRequest {
    return new QueryValsetRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetRequestRequest {
    return new QueryValsetRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetRequestRequest | PlainMessage<QueryValsetRequestRequest> | undefined, b: QueryValsetRequestRequest | PlainMessage<QueryValsetRequestRequest> | undefined): boolean {
    return proto3.util.equals(QueryValsetRequestRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetRequestResponse
 */
export class QueryValsetRequestResponse extends Message<QueryValsetRequestResponse> {
  /**
   * @generated from field: injective.peggy.v1.Valset valset = 1;
   */
  valset?: Valset;

  constructor(data?: PartialMessage<QueryValsetRequestResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetRequestResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valset", kind: "message", T: Valset },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetRequestResponse {
    return new QueryValsetRequestResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetRequestResponse {
    return new QueryValsetRequestResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetRequestResponse {
    return new QueryValsetRequestResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetRequestResponse | PlainMessage<QueryValsetRequestResponse> | undefined, b: QueryValsetRequestResponse | PlainMessage<QueryValsetRequestResponse> | undefined): boolean {
    return proto3.util.equals(QueryValsetRequestResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetConfirmRequest
 */
export class QueryValsetConfirmRequest extends Message<QueryValsetConfirmRequest> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * @generated from field: string address = 2;
   */
  address = "";

  constructor(data?: PartialMessage<QueryValsetConfirmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetConfirmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetConfirmRequest {
    return new QueryValsetConfirmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetConfirmRequest {
    return new QueryValsetConfirmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetConfirmRequest {
    return new QueryValsetConfirmRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetConfirmRequest | PlainMessage<QueryValsetConfirmRequest> | undefined, b: QueryValsetConfirmRequest | PlainMessage<QueryValsetConfirmRequest> | undefined): boolean {
    return proto3.util.equals(QueryValsetConfirmRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetConfirmResponse
 */
export class QueryValsetConfirmResponse extends Message<QueryValsetConfirmResponse> {
  /**
   * @generated from field: injective.peggy.v1.MsgValsetConfirm confirm = 1;
   */
  confirm?: MsgValsetConfirm;

  constructor(data?: PartialMessage<QueryValsetConfirmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetConfirmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirm", kind: "message", T: MsgValsetConfirm },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetConfirmResponse {
    return new QueryValsetConfirmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetConfirmResponse {
    return new QueryValsetConfirmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetConfirmResponse {
    return new QueryValsetConfirmResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetConfirmResponse | PlainMessage<QueryValsetConfirmResponse> | undefined, b: QueryValsetConfirmResponse | PlainMessage<QueryValsetConfirmResponse> | undefined): boolean {
    return proto3.util.equals(QueryValsetConfirmResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetConfirmsByNonceRequest
 */
export class QueryValsetConfirmsByNonceRequest extends Message<QueryValsetConfirmsByNonceRequest> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  constructor(data?: PartialMessage<QueryValsetConfirmsByNonceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetConfirmsByNonceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetConfirmsByNonceRequest {
    return new QueryValsetConfirmsByNonceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetConfirmsByNonceRequest {
    return new QueryValsetConfirmsByNonceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetConfirmsByNonceRequest {
    return new QueryValsetConfirmsByNonceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetConfirmsByNonceRequest | PlainMessage<QueryValsetConfirmsByNonceRequest> | undefined, b: QueryValsetConfirmsByNonceRequest | PlainMessage<QueryValsetConfirmsByNonceRequest> | undefined): boolean {
    return proto3.util.equals(QueryValsetConfirmsByNonceRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryValsetConfirmsByNonceResponse
 */
export class QueryValsetConfirmsByNonceResponse extends Message<QueryValsetConfirmsByNonceResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.MsgValsetConfirm confirms = 1;
   */
  confirms: MsgValsetConfirm[] = [];

  constructor(data?: PartialMessage<QueryValsetConfirmsByNonceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryValsetConfirmsByNonceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirms", kind: "message", T: MsgValsetConfirm, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValsetConfirmsByNonceResponse {
    return new QueryValsetConfirmsByNonceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValsetConfirmsByNonceResponse {
    return new QueryValsetConfirmsByNonceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValsetConfirmsByNonceResponse {
    return new QueryValsetConfirmsByNonceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValsetConfirmsByNonceResponse | PlainMessage<QueryValsetConfirmsByNonceResponse> | undefined, b: QueryValsetConfirmsByNonceResponse | PlainMessage<QueryValsetConfirmsByNonceResponse> | undefined): boolean {
    return proto3.util.equals(QueryValsetConfirmsByNonceResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastValsetRequestsRequest
 */
export class QueryLastValsetRequestsRequest extends Message<QueryLastValsetRequestsRequest> {
  constructor(data?: PartialMessage<QueryLastValsetRequestsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastValsetRequestsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastValsetRequestsRequest {
    return new QueryLastValsetRequestsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastValsetRequestsRequest {
    return new QueryLastValsetRequestsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastValsetRequestsRequest {
    return new QueryLastValsetRequestsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastValsetRequestsRequest | PlainMessage<QueryLastValsetRequestsRequest> | undefined, b: QueryLastValsetRequestsRequest | PlainMessage<QueryLastValsetRequestsRequest> | undefined): boolean {
    return proto3.util.equals(QueryLastValsetRequestsRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastValsetRequestsResponse
 */
export class QueryLastValsetRequestsResponse extends Message<QueryLastValsetRequestsResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.Valset valsets = 1;
   */
  valsets: Valset[] = [];

  constructor(data?: PartialMessage<QueryLastValsetRequestsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastValsetRequestsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valsets", kind: "message", T: Valset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastValsetRequestsResponse {
    return new QueryLastValsetRequestsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastValsetRequestsResponse {
    return new QueryLastValsetRequestsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastValsetRequestsResponse {
    return new QueryLastValsetRequestsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastValsetRequestsResponse | PlainMessage<QueryLastValsetRequestsResponse> | undefined, b: QueryLastValsetRequestsResponse | PlainMessage<QueryLastValsetRequestsResponse> | undefined): boolean {
    return proto3.util.equals(QueryLastValsetRequestsResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest
 */
export class QueryLastPendingValsetRequestByAddrRequest extends Message<QueryLastPendingValsetRequestByAddrRequest> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryLastPendingValsetRequestByAddrRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastPendingValsetRequestByAddrRequest {
    return new QueryLastPendingValsetRequestByAddrRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastPendingValsetRequestByAddrRequest {
    return new QueryLastPendingValsetRequestByAddrRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastPendingValsetRequestByAddrRequest {
    return new QueryLastPendingValsetRequestByAddrRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastPendingValsetRequestByAddrRequest | PlainMessage<QueryLastPendingValsetRequestByAddrRequest> | undefined, b: QueryLastPendingValsetRequestByAddrRequest | PlainMessage<QueryLastPendingValsetRequestByAddrRequest> | undefined): boolean {
    return proto3.util.equals(QueryLastPendingValsetRequestByAddrRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse
 */
export class QueryLastPendingValsetRequestByAddrResponse extends Message<QueryLastPendingValsetRequestByAddrResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.Valset valsets = 1;
   */
  valsets: Valset[] = [];

  constructor(data?: PartialMessage<QueryLastPendingValsetRequestByAddrResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valsets", kind: "message", T: Valset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastPendingValsetRequestByAddrResponse {
    return new QueryLastPendingValsetRequestByAddrResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastPendingValsetRequestByAddrResponse {
    return new QueryLastPendingValsetRequestByAddrResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastPendingValsetRequestByAddrResponse {
    return new QueryLastPendingValsetRequestByAddrResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastPendingValsetRequestByAddrResponse | PlainMessage<QueryLastPendingValsetRequestByAddrResponse> | undefined, b: QueryLastPendingValsetRequestByAddrResponse | PlainMessage<QueryLastPendingValsetRequestByAddrResponse> | undefined): boolean {
    return proto3.util.equals(QueryLastPendingValsetRequestByAddrResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchFeeRequest
 */
export class QueryBatchFeeRequest extends Message<QueryBatchFeeRequest> {
  constructor(data?: PartialMessage<QueryBatchFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchFeeRequest {
    return new QueryBatchFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchFeeRequest {
    return new QueryBatchFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchFeeRequest {
    return new QueryBatchFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchFeeRequest | PlainMessage<QueryBatchFeeRequest> | undefined, b: QueryBatchFeeRequest | PlainMessage<QueryBatchFeeRequest> | undefined): boolean {
    return proto3.util.equals(QueryBatchFeeRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchFeeResponse
 */
export class QueryBatchFeeResponse extends Message<QueryBatchFeeResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.BatchFees batchFees = 1;
   */
  batchFees: BatchFees[] = [];

  constructor(data?: PartialMessage<QueryBatchFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "batchFees", kind: "message", T: BatchFees, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchFeeResponse {
    return new QueryBatchFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchFeeResponse {
    return new QueryBatchFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchFeeResponse {
    return new QueryBatchFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchFeeResponse | PlainMessage<QueryBatchFeeResponse> | undefined, b: QueryBatchFeeResponse | PlainMessage<QueryBatchFeeResponse> | undefined): boolean {
    return proto3.util.equals(QueryBatchFeeResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest
 */
export class QueryLastPendingBatchRequestByAddrRequest extends Message<QueryLastPendingBatchRequestByAddrRequest> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryLastPendingBatchRequestByAddrRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastPendingBatchRequestByAddrRequest {
    return new QueryLastPendingBatchRequestByAddrRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastPendingBatchRequestByAddrRequest {
    return new QueryLastPendingBatchRequestByAddrRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastPendingBatchRequestByAddrRequest {
    return new QueryLastPendingBatchRequestByAddrRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastPendingBatchRequestByAddrRequest | PlainMessage<QueryLastPendingBatchRequestByAddrRequest> | undefined, b: QueryLastPendingBatchRequestByAddrRequest | PlainMessage<QueryLastPendingBatchRequestByAddrRequest> | undefined): boolean {
    return proto3.util.equals(QueryLastPendingBatchRequestByAddrRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse
 */
export class QueryLastPendingBatchRequestByAddrResponse extends Message<QueryLastPendingBatchRequestByAddrResponse> {
  /**
   * @generated from field: injective.peggy.v1.OutgoingTxBatch batch = 1;
   */
  batch?: OutgoingTxBatch;

  constructor(data?: PartialMessage<QueryLastPendingBatchRequestByAddrResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "batch", kind: "message", T: OutgoingTxBatch },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastPendingBatchRequestByAddrResponse {
    return new QueryLastPendingBatchRequestByAddrResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastPendingBatchRequestByAddrResponse {
    return new QueryLastPendingBatchRequestByAddrResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastPendingBatchRequestByAddrResponse {
    return new QueryLastPendingBatchRequestByAddrResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastPendingBatchRequestByAddrResponse | PlainMessage<QueryLastPendingBatchRequestByAddrResponse> | undefined, b: QueryLastPendingBatchRequestByAddrResponse | PlainMessage<QueryLastPendingBatchRequestByAddrResponse> | undefined): boolean {
    return proto3.util.equals(QueryLastPendingBatchRequestByAddrResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryOutgoingTxBatchesRequest
 */
export class QueryOutgoingTxBatchesRequest extends Message<QueryOutgoingTxBatchesRequest> {
  constructor(data?: PartialMessage<QueryOutgoingTxBatchesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryOutgoingTxBatchesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOutgoingTxBatchesRequest {
    return new QueryOutgoingTxBatchesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOutgoingTxBatchesRequest {
    return new QueryOutgoingTxBatchesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOutgoingTxBatchesRequest {
    return new QueryOutgoingTxBatchesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOutgoingTxBatchesRequest | PlainMessage<QueryOutgoingTxBatchesRequest> | undefined, b: QueryOutgoingTxBatchesRequest | PlainMessage<QueryOutgoingTxBatchesRequest> | undefined): boolean {
    return proto3.util.equals(QueryOutgoingTxBatchesRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryOutgoingTxBatchesResponse
 */
export class QueryOutgoingTxBatchesResponse extends Message<QueryOutgoingTxBatchesResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.OutgoingTxBatch batches = 1;
   */
  batches: OutgoingTxBatch[] = [];

  constructor(data?: PartialMessage<QueryOutgoingTxBatchesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryOutgoingTxBatchesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "batches", kind: "message", T: OutgoingTxBatch, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOutgoingTxBatchesResponse {
    return new QueryOutgoingTxBatchesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOutgoingTxBatchesResponse {
    return new QueryOutgoingTxBatchesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOutgoingTxBatchesResponse {
    return new QueryOutgoingTxBatchesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOutgoingTxBatchesResponse | PlainMessage<QueryOutgoingTxBatchesResponse> | undefined, b: QueryOutgoingTxBatchesResponse | PlainMessage<QueryOutgoingTxBatchesResponse> | undefined): boolean {
    return proto3.util.equals(QueryOutgoingTxBatchesResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchRequestByNonceRequest
 */
export class QueryBatchRequestByNonceRequest extends Message<QueryBatchRequestByNonceRequest> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * @generated from field: string contract_address = 2;
   */
  contractAddress = "";

  constructor(data?: PartialMessage<QueryBatchRequestByNonceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchRequestByNonceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchRequestByNonceRequest {
    return new QueryBatchRequestByNonceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchRequestByNonceRequest {
    return new QueryBatchRequestByNonceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchRequestByNonceRequest {
    return new QueryBatchRequestByNonceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchRequestByNonceRequest | PlainMessage<QueryBatchRequestByNonceRequest> | undefined, b: QueryBatchRequestByNonceRequest | PlainMessage<QueryBatchRequestByNonceRequest> | undefined): boolean {
    return proto3.util.equals(QueryBatchRequestByNonceRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchRequestByNonceResponse
 */
export class QueryBatchRequestByNonceResponse extends Message<QueryBatchRequestByNonceResponse> {
  /**
   * @generated from field: injective.peggy.v1.OutgoingTxBatch batch = 1;
   */
  batch?: OutgoingTxBatch;

  constructor(data?: PartialMessage<QueryBatchRequestByNonceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchRequestByNonceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "batch", kind: "message", T: OutgoingTxBatch },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchRequestByNonceResponse {
    return new QueryBatchRequestByNonceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchRequestByNonceResponse {
    return new QueryBatchRequestByNonceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchRequestByNonceResponse {
    return new QueryBatchRequestByNonceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchRequestByNonceResponse | PlainMessage<QueryBatchRequestByNonceResponse> | undefined, b: QueryBatchRequestByNonceResponse | PlainMessage<QueryBatchRequestByNonceResponse> | undefined): boolean {
    return proto3.util.equals(QueryBatchRequestByNonceResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchConfirmsRequest
 */
export class QueryBatchConfirmsRequest extends Message<QueryBatchConfirmsRequest> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * @generated from field: string contract_address = 2;
   */
  contractAddress = "";

  constructor(data?: PartialMessage<QueryBatchConfirmsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchConfirmsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchConfirmsRequest {
    return new QueryBatchConfirmsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchConfirmsRequest {
    return new QueryBatchConfirmsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchConfirmsRequest {
    return new QueryBatchConfirmsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchConfirmsRequest | PlainMessage<QueryBatchConfirmsRequest> | undefined, b: QueryBatchConfirmsRequest | PlainMessage<QueryBatchConfirmsRequest> | undefined): boolean {
    return proto3.util.equals(QueryBatchConfirmsRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryBatchConfirmsResponse
 */
export class QueryBatchConfirmsResponse extends Message<QueryBatchConfirmsResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.MsgConfirmBatch confirms = 1;
   */
  confirms: MsgConfirmBatch[] = [];

  constructor(data?: PartialMessage<QueryBatchConfirmsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryBatchConfirmsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirms", kind: "message", T: MsgConfirmBatch, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchConfirmsResponse {
    return new QueryBatchConfirmsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchConfirmsResponse {
    return new QueryBatchConfirmsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchConfirmsResponse {
    return new QueryBatchConfirmsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBatchConfirmsResponse | PlainMessage<QueryBatchConfirmsResponse> | undefined, b: QueryBatchConfirmsResponse | PlainMessage<QueryBatchConfirmsResponse> | undefined): boolean {
    return proto3.util.equals(QueryBatchConfirmsResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastEventByAddrRequest
 */
export class QueryLastEventByAddrRequest extends Message<QueryLastEventByAddrRequest> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryLastEventByAddrRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastEventByAddrRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastEventByAddrRequest {
    return new QueryLastEventByAddrRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastEventByAddrRequest {
    return new QueryLastEventByAddrRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastEventByAddrRequest {
    return new QueryLastEventByAddrRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastEventByAddrRequest | PlainMessage<QueryLastEventByAddrRequest> | undefined, b: QueryLastEventByAddrRequest | PlainMessage<QueryLastEventByAddrRequest> | undefined): boolean {
    return proto3.util.equals(QueryLastEventByAddrRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryLastEventByAddrResponse
 */
export class QueryLastEventByAddrResponse extends Message<QueryLastEventByAddrResponse> {
  /**
   * @generated from field: injective.peggy.v1.LastClaimEvent last_claim_event = 1;
   */
  lastClaimEvent?: LastClaimEvent;

  constructor(data?: PartialMessage<QueryLastEventByAddrResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryLastEventByAddrResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_claim_event", kind: "message", T: LastClaimEvent },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryLastEventByAddrResponse {
    return new QueryLastEventByAddrResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryLastEventByAddrResponse {
    return new QueryLastEventByAddrResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryLastEventByAddrResponse {
    return new QueryLastEventByAddrResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryLastEventByAddrResponse | PlainMessage<QueryLastEventByAddrResponse> | undefined, b: QueryLastEventByAddrResponse | PlainMessage<QueryLastEventByAddrResponse> | undefined): boolean {
    return proto3.util.equals(QueryLastEventByAddrResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryERC20ToDenomRequest
 */
export class QueryERC20ToDenomRequest extends Message<QueryERC20ToDenomRequest> {
  /**
   * @generated from field: string erc20 = 1;
   */
  erc20 = "";

  constructor(data?: PartialMessage<QueryERC20ToDenomRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryERC20ToDenomRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "erc20", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryERC20ToDenomRequest {
    return new QueryERC20ToDenomRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryERC20ToDenomRequest {
    return new QueryERC20ToDenomRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryERC20ToDenomRequest {
    return new QueryERC20ToDenomRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryERC20ToDenomRequest | PlainMessage<QueryERC20ToDenomRequest> | undefined, b: QueryERC20ToDenomRequest | PlainMessage<QueryERC20ToDenomRequest> | undefined): boolean {
    return proto3.util.equals(QueryERC20ToDenomRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryERC20ToDenomResponse
 */
export class QueryERC20ToDenomResponse extends Message<QueryERC20ToDenomResponse> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: bool cosmos_originated = 2;
   */
  cosmosOriginated = false;

  constructor(data?: PartialMessage<QueryERC20ToDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryERC20ToDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cosmos_originated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryERC20ToDenomResponse {
    return new QueryERC20ToDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryERC20ToDenomResponse {
    return new QueryERC20ToDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryERC20ToDenomResponse {
    return new QueryERC20ToDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryERC20ToDenomResponse | PlainMessage<QueryERC20ToDenomResponse> | undefined, b: QueryERC20ToDenomResponse | PlainMessage<QueryERC20ToDenomResponse> | undefined): boolean {
    return proto3.util.equals(QueryERC20ToDenomResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDenomToERC20Request
 */
export class QueryDenomToERC20Request extends Message<QueryDenomToERC20Request> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  constructor(data?: PartialMessage<QueryDenomToERC20Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDenomToERC20Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomToERC20Request {
    return new QueryDenomToERC20Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomToERC20Request {
    return new QueryDenomToERC20Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomToERC20Request {
    return new QueryDenomToERC20Request().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomToERC20Request | PlainMessage<QueryDenomToERC20Request> | undefined, b: QueryDenomToERC20Request | PlainMessage<QueryDenomToERC20Request> | undefined): boolean {
    return proto3.util.equals(QueryDenomToERC20Request, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDenomToERC20Response
 */
export class QueryDenomToERC20Response extends Message<QueryDenomToERC20Response> {
  /**
   * @generated from field: string erc20 = 1;
   */
  erc20 = "";

  /**
   * @generated from field: bool cosmos_originated = 2;
   */
  cosmosOriginated = false;

  constructor(data?: PartialMessage<QueryDenomToERC20Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDenomToERC20Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "erc20", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cosmos_originated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomToERC20Response {
    return new QueryDenomToERC20Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomToERC20Response {
    return new QueryDenomToERC20Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomToERC20Response {
    return new QueryDenomToERC20Response().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomToERC20Response | PlainMessage<QueryDenomToERC20Response> | undefined, b: QueryDenomToERC20Response | PlainMessage<QueryDenomToERC20Response> | undefined): boolean {
    return proto3.util.equals(QueryDenomToERC20Response, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByValidatorAddress
 */
export class QueryDelegateKeysByValidatorAddress extends Message<QueryDelegateKeysByValidatorAddress> {
  /**
   * @generated from field: string validator_address = 1;
   */
  validatorAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByValidatorAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByValidatorAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByValidatorAddress {
    return new QueryDelegateKeysByValidatorAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByValidatorAddress {
    return new QueryDelegateKeysByValidatorAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByValidatorAddress {
    return new QueryDelegateKeysByValidatorAddress().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByValidatorAddress | PlainMessage<QueryDelegateKeysByValidatorAddress> | undefined, b: QueryDelegateKeysByValidatorAddress | PlainMessage<QueryDelegateKeysByValidatorAddress> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByValidatorAddress, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse
 */
export class QueryDelegateKeysByValidatorAddressResponse extends Message<QueryDelegateKeysByValidatorAddressResponse> {
  /**
   * @generated from field: string eth_address = 1;
   */
  ethAddress = "";

  /**
   * @generated from field: string orchestrator_address = 2;
   */
  orchestratorAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByValidatorAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eth_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByValidatorAddressResponse {
    return new QueryDelegateKeysByValidatorAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByValidatorAddressResponse {
    return new QueryDelegateKeysByValidatorAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByValidatorAddressResponse {
    return new QueryDelegateKeysByValidatorAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByValidatorAddressResponse | PlainMessage<QueryDelegateKeysByValidatorAddressResponse> | undefined, b: QueryDelegateKeysByValidatorAddressResponse | PlainMessage<QueryDelegateKeysByValidatorAddressResponse> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByValidatorAddressResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByEthAddress
 */
export class QueryDelegateKeysByEthAddress extends Message<QueryDelegateKeysByEthAddress> {
  /**
   * @generated from field: string eth_address = 1;
   */
  ethAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByEthAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByEthAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eth_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByEthAddress {
    return new QueryDelegateKeysByEthAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByEthAddress {
    return new QueryDelegateKeysByEthAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByEthAddress {
    return new QueryDelegateKeysByEthAddress().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByEthAddress | PlainMessage<QueryDelegateKeysByEthAddress> | undefined, b: QueryDelegateKeysByEthAddress | PlainMessage<QueryDelegateKeysByEthAddress> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByEthAddress, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByEthAddressResponse
 */
export class QueryDelegateKeysByEthAddressResponse extends Message<QueryDelegateKeysByEthAddressResponse> {
  /**
   * @generated from field: string validator_address = 1;
   */
  validatorAddress = "";

  /**
   * @generated from field: string orchestrator_address = 2;
   */
  orchestratorAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByEthAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByEthAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "orchestrator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByEthAddressResponse {
    return new QueryDelegateKeysByEthAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByEthAddressResponse {
    return new QueryDelegateKeysByEthAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByEthAddressResponse {
    return new QueryDelegateKeysByEthAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByEthAddressResponse | PlainMessage<QueryDelegateKeysByEthAddressResponse> | undefined, b: QueryDelegateKeysByEthAddressResponse | PlainMessage<QueryDelegateKeysByEthAddressResponse> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByEthAddressResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress
 */
export class QueryDelegateKeysByOrchestratorAddress extends Message<QueryDelegateKeysByOrchestratorAddress> {
  /**
   * @generated from field: string orchestrator_address = 1;
   */
  orchestratorAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByOrchestratorAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orchestrator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByOrchestratorAddress {
    return new QueryDelegateKeysByOrchestratorAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByOrchestratorAddress {
    return new QueryDelegateKeysByOrchestratorAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByOrchestratorAddress {
    return new QueryDelegateKeysByOrchestratorAddress().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByOrchestratorAddress | PlainMessage<QueryDelegateKeysByOrchestratorAddress> | undefined, b: QueryDelegateKeysByOrchestratorAddress | PlainMessage<QueryDelegateKeysByOrchestratorAddress> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByOrchestratorAddress, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse
 */
export class QueryDelegateKeysByOrchestratorAddressResponse extends Message<QueryDelegateKeysByOrchestratorAddressResponse> {
  /**
   * @generated from field: string validator_address = 1;
   */
  validatorAddress = "";

  /**
   * @generated from field: string eth_address = 2;
   */
  ethAddress = "";

  constructor(data?: PartialMessage<QueryDelegateKeysByOrchestratorAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "eth_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDelegateKeysByOrchestratorAddressResponse {
    return new QueryDelegateKeysByOrchestratorAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDelegateKeysByOrchestratorAddressResponse {
    return new QueryDelegateKeysByOrchestratorAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDelegateKeysByOrchestratorAddressResponse {
    return new QueryDelegateKeysByOrchestratorAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDelegateKeysByOrchestratorAddressResponse | PlainMessage<QueryDelegateKeysByOrchestratorAddressResponse> | undefined, b: QueryDelegateKeysByOrchestratorAddressResponse | PlainMessage<QueryDelegateKeysByOrchestratorAddressResponse> | undefined): boolean {
    return proto3.util.equals(QueryDelegateKeysByOrchestratorAddressResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryPendingSendToEth
 */
export class QueryPendingSendToEth extends Message<QueryPendingSendToEth> {
  /**
   * @generated from field: string sender_address = 1;
   */
  senderAddress = "";

  constructor(data?: PartialMessage<QueryPendingSendToEth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryPendingSendToEth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPendingSendToEth {
    return new QueryPendingSendToEth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPendingSendToEth {
    return new QueryPendingSendToEth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPendingSendToEth {
    return new QueryPendingSendToEth().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPendingSendToEth | PlainMessage<QueryPendingSendToEth> | undefined, b: QueryPendingSendToEth | PlainMessage<QueryPendingSendToEth> | undefined): boolean {
    return proto3.util.equals(QueryPendingSendToEth, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.QueryPendingSendToEthResponse
 */
export class QueryPendingSendToEthResponse extends Message<QueryPendingSendToEthResponse> {
  /**
   * @generated from field: repeated injective.peggy.v1.OutgoingTransferTx transfers_in_batches = 1;
   */
  transfersInBatches: OutgoingTransferTx[] = [];

  /**
   * @generated from field: repeated injective.peggy.v1.OutgoingTransferTx unbatched_transfers = 2;
   */
  unbatchedTransfers: OutgoingTransferTx[] = [];

  constructor(data?: PartialMessage<QueryPendingSendToEthResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryPendingSendToEthResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transfers_in_batches", kind: "message", T: OutgoingTransferTx, repeated: true },
    { no: 2, name: "unbatched_transfers", kind: "message", T: OutgoingTransferTx, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPendingSendToEthResponse {
    return new QueryPendingSendToEthResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPendingSendToEthResponse {
    return new QueryPendingSendToEthResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPendingSendToEthResponse {
    return new QueryPendingSendToEthResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPendingSendToEthResponse | PlainMessage<QueryPendingSendToEthResponse> | undefined, b: QueryPendingSendToEthResponse | PlainMessage<QueryPendingSendToEthResponse> | undefined): boolean {
    return proto3.util.equals(QueryPendingSendToEthResponse, a, b);
  }
}

/**
 * QueryModuleStateRequest is the request type for the Query/PeggyModuleState
 * RPC method.
 *
 * @generated from message injective.peggy.v1.QueryModuleStateRequest
 */
export class QueryModuleStateRequest extends Message<QueryModuleStateRequest> {
  constructor(data?: PartialMessage<QueryModuleStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryModuleStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryModuleStateRequest | PlainMessage<QueryModuleStateRequest> | undefined, b: QueryModuleStateRequest | PlainMessage<QueryModuleStateRequest> | undefined): boolean {
    return proto3.util.equals(QueryModuleStateRequest, a, b);
  }
}

/**
 * QueryModuleStateResponse is the response type for the Query/PeggyModuleState
 * RPC method.
 *
 * @generated from message injective.peggy.v1.QueryModuleStateResponse
 */
export class QueryModuleStateResponse extends Message<QueryModuleStateResponse> {
  /**
   * @generated from field: injective.peggy.v1.GenesisState state = 1;
   */
  state?: GenesisState;

  constructor(data?: PartialMessage<QueryModuleStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.QueryModuleStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: GenesisState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryModuleStateResponse | PlainMessage<QueryModuleStateResponse> | undefined, b: QueryModuleStateResponse | PlainMessage<QueryModuleStateResponse> | undefined): boolean {
    return proto3.util.equals(QueryModuleStateResponse, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.MissingNoncesRequest
 */
export class MissingNoncesRequest extends Message<MissingNoncesRequest> {
  constructor(data?: PartialMessage<MissingNoncesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.MissingNoncesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MissingNoncesRequest {
    return new MissingNoncesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MissingNoncesRequest {
    return new MissingNoncesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MissingNoncesRequest {
    return new MissingNoncesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MissingNoncesRequest | PlainMessage<MissingNoncesRequest> | undefined, b: MissingNoncesRequest | PlainMessage<MissingNoncesRequest> | undefined): boolean {
    return proto3.util.equals(MissingNoncesRequest, a, b);
  }
}

/**
 * @generated from message injective.peggy.v1.MissingNoncesResponse
 */
export class MissingNoncesResponse extends Message<MissingNoncesResponse> {
  /**
   * @generated from field: repeated string operator_addresses = 1;
   */
  operatorAddresses: string[] = [];

  constructor(data?: PartialMessage<MissingNoncesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.peggy.v1.MissingNoncesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MissingNoncesResponse {
    return new MissingNoncesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MissingNoncesResponse {
    return new MissingNoncesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MissingNoncesResponse {
    return new MissingNoncesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MissingNoncesResponse | PlainMessage<MissingNoncesResponse> | undefined, b: MissingNoncesResponse | PlainMessage<MissingNoncesResponse> | undefined): boolean {
    return proto3.util.equals(MissingNoncesResponse, a, b);
  }
}

