// @generated by protoc-gen-es v1.7.0 with parameter "target=ts"
// @generated from file initia/move/v1/types.proto (package initia.move.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * UpgradePolicy
 * * `arbitrary`
 *     Whether unconditional code upgrade with no compatibility check is allowed. This
 *     publication mode should only be used for modules which aren't shared with user others.
 *     The developer is responsible for not breaking memory layout of any resources he already
 *     stored on chain.
 * * `compatible`
 *     Whether a compatibility check should be performed for upgrades. The check only passes if
 *     a new module has (a) the same public functions (b) for existing resources, no layout change.
 * * `immutable`
 *     Whether the modules in the package are immutable and cannot be upgraded.
 *
 * @generated from enum initia.move.v1.UpgradePolicy
 */
export enum UpgradePolicy {
  /**
   * @generated from enum value: ARBITRARY = 0;
   */
  ARBITRARY = 0,

  /**
   * @generated from enum value: COMPATIBLE = 1;
   */
  COMPATIBLE = 1,

  /**
   * @generated from enum value: IMMUTABLE = 2;
   */
  IMMUTABLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UpgradePolicy)
proto3.util.setEnumType(UpgradePolicy, "initia.move.v1.UpgradePolicy", [
  { no: 0, name: "ARBITRARY" },
  { no: 1, name: "COMPATIBLE" },
  { no: 2, name: "IMMUTABLE" },
]);

/**
 * Params defines the set of move parameters.
 *
 * @generated from message initia.move.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * @generated from field: string base_denom = 1;
   */
  baseDenom = "";

  /**
   * @generated from field: string base_min_gas_price = 2;
   */
  baseMinGasPrice = "";

  /**
   * @generated from field: bool arbitrary_enabled = 3;
   */
  arbitraryEnabled = false;

  /**
   * CSR: Percentage of fees distributed to developers
   *
   * @generated from field: string contract_shared_revenue_ratio = 4;
   */
  contractSharedRevenueRatio = "";

  /**
   * It is a list of addresses with permission to distribute contracts,
   * and an empty list is interpreted as allowing anyone to distribute.
   *
   * @generated from field: repeated string allowed_publishers = 5;
   */
  allowedPublishers: string[] = [];

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_min_gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arbitrary_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "contract_shared_revenue_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "allowed_publishers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * RawParams defines the raw params to store.
 *
 * @generated from message initia.move.v1.RawParams
 */
export class RawParams extends Message<RawParams> {
  /**
   * @generated from field: string base_denom = 1;
   */
  baseDenom = "";

  /**
   * @generated from field: string base_min_gas_price = 2;
   */
  baseMinGasPrice = "";

  /**
   * CSR: Percentage of fees distributed to developers
   *
   * @generated from field: string contract_shared_revenue_ratio = 3;
   */
  contractSharedRevenueRatio = "";

  constructor(data?: PartialMessage<RawParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.RawParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_min_gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contract_shared_revenue_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RawParams {
    return new RawParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RawParams {
    return new RawParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RawParams {
    return new RawParams().fromJsonString(jsonString, options);
  }

  static equals(a: RawParams | PlainMessage<RawParams> | undefined, b: RawParams | PlainMessage<RawParams> | undefined): boolean {
    return proto3.util.equals(RawParams, a, b);
  }
}

/**
 * Module is data for the uploaded contract move code
 * ex) 0000000000000000000000000000000000000001/0/BasicCoin
 *
 * @generated from message initia.move.v1.Module
 */
export class Module extends Message<Module> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string module_name = 2;
   */
  moduleName = "";

  /**
   * @generated from field: string abi = 3;
   */
  abi = "";

  /**
   * @generated from field: bytes raw_bytes = 4;
   */
  rawBytes = new Uint8Array(0);

  /**
   * @generated from field: initia.move.v1.UpgradePolicy upgrade_policy = 5;
   */
  upgradePolicy = UpgradePolicy.ARBITRARY;

  constructor(data?: PartialMessage<Module>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.Module";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "abi", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "raw_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "upgrade_policy", kind: "enum", T: proto3.getEnumType(UpgradePolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Module {
    return new Module().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJsonString(jsonString, options);
  }

  static equals(a: Module | PlainMessage<Module> | undefined, b: Module | PlainMessage<Module> | undefined): boolean {
    return proto3.util.equals(Module, a, b);
  }
}

/**
 * Resource is data for the stored move resource
 * ex) 0000000000000000000000000000000000000002/2/0x1::BasicCoin::Coin<0x1::BasicCoin::Initia>
 *
 * @generated from message initia.move.v1.Resource
 */
export class Resource extends Message<Resource> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string struct_tag = 2;
   */
  structTag = "";

  /**
   * @generated from field: string move_resource = 3;
   */
  moveResource = "";

  /**
   * @generated from field: bytes raw_bytes = 4;
   */
  rawBytes = new Uint8Array(0);

  constructor(data?: PartialMessage<Resource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.Resource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "struct_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "move_resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "raw_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Resource {
    return new Resource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJsonString(jsonString, options);
  }

  static equals(a: Resource | PlainMessage<Resource> | undefined, b: Resource | PlainMessage<Resource> | undefined): boolean {
    return proto3.util.equals(Resource, a, b);
  }
}

/**
 * TableInfo is data stored under Table address
 *
 * @generated from message initia.move.v1.TableInfo
 */
export class TableInfo extends Message<TableInfo> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string key_type = 2;
   */
  keyType = "";

  /**
   * @generated from field: string value_type = 3;
   */
  valueType = "";

  constructor(data?: PartialMessage<TableInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.TableInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableInfo {
    return new TableInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableInfo {
    return new TableInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableInfo {
    return new TableInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TableInfo | PlainMessage<TableInfo> | undefined, b: TableInfo | PlainMessage<TableInfo> | undefined): boolean {
    return proto3.util.equals(TableInfo, a, b);
  }
}

/**
 * TableEntry is data stored under Table address and the key bytes
 *
 * @generated from message initia.move.v1.TableEntry
 */
export class TableEntry extends Message<TableEntry> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  /**
   * @generated from field: bytes key_bytes = 4;
   */
  keyBytes = new Uint8Array(0);

  /**
   * @generated from field: bytes value_bytes = 5;
   */
  valueBytes = new Uint8Array(0);

  constructor(data?: PartialMessage<TableEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.TableEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "key_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "value_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableEntry {
    return new TableEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableEntry {
    return new TableEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableEntry {
    return new TableEntry().fromJsonString(jsonString, options);
  }

  static equals(a: TableEntry | PlainMessage<TableEntry> | undefined, b: TableEntry | PlainMessage<TableEntry> | undefined): boolean {
    return proto3.util.equals(TableEntry, a, b);
  }
}

/**
 * proto wrapper to store the value
 *
 * @generated from message initia.move.v1.UpgradePolicyProto
 */
export class UpgradePolicyProto extends Message<UpgradePolicyProto> {
  /**
   * @generated from field: initia.move.v1.UpgradePolicy policy = 1;
   */
  policy = UpgradePolicy.ARBITRARY;

  constructor(data?: PartialMessage<UpgradePolicyProto>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.UpgradePolicyProto";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "policy", kind: "enum", T: proto3.getEnumType(UpgradePolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradePolicyProto {
    return new UpgradePolicyProto().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradePolicyProto {
    return new UpgradePolicyProto().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradePolicyProto {
    return new UpgradePolicyProto().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradePolicyProto | PlainMessage<UpgradePolicyProto> | undefined, b: UpgradePolicyProto | PlainMessage<UpgradePolicyProto> | undefined): boolean {
    return proto3.util.equals(UpgradePolicyProto, a, b);
  }
}

/**
 * DexPair contains coin metdata address
 * std::dex::Pool and std::dex::Config resources.
 *
 * @generated from message initia.move.v1.DexPair
 */
export class DexPair extends Message<DexPair> {
  /**
   * @generated from field: string metadata_quote = 1;
   */
  metadataQuote = "";

  /**
   * @generated from field: string metadata_lp = 2;
   */
  metadataLp = "";

  constructor(data?: PartialMessage<DexPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.DexPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata_lp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DexPair {
    return new DexPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DexPair {
    return new DexPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DexPair {
    return new DexPair().fromJsonString(jsonString, options);
  }

  static equals(a: DexPair | PlainMessage<DexPair> | undefined, b: DexPair | PlainMessage<DexPair> | undefined): boolean {
    return proto3.util.equals(DexPair, a, b);
  }
}

/**
 * ExecuteAuthorizationItem is the information for granting module execution
 *
 * @generated from message initia.move.v1.ExecuteAuthorizationItem
 */
export class ExecuteAuthorizationItem extends Message<ExecuteAuthorizationItem> {
  /**
   * ModuleAddr is the address of the module deployer
   *
   * @generated from field: string module_address = 1;
   */
  moduleAddress = "";

  /**
   * ModuleName is the names of module to execute
   *
   * @generated from field: string module_name = 2;
   */
  moduleName = "";

  /**
   * FunctionName is the name of function to execute with wildcard '*' support
   *
   * @generated from field: repeated string function_names = 3;
   */
  functionNames: string[] = [];

  constructor(data?: PartialMessage<ExecuteAuthorizationItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "initia.move.v1.ExecuteAuthorizationItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "function_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteAuthorizationItem {
    return new ExecuteAuthorizationItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteAuthorizationItem {
    return new ExecuteAuthorizationItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteAuthorizationItem {
    return new ExecuteAuthorizationItem().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteAuthorizationItem | PlainMessage<ExecuteAuthorizationItem> | undefined, b: ExecuteAuthorizationItem | PlainMessage<ExecuteAuthorizationItem> | undefined): boolean {
    return proto3.util.equals(ExecuteAuthorizationItem, a, b);
  }
}

